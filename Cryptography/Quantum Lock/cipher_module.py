#!/usr/bin/env python3
"""
OBLIVION Cipher Module v1.0
"""

import sys

BLOCK_SIZE = 16
ROUNDS = 8
SBOX = [140, 147, 152, 148, 29, 132, 128, 42, 223, 238, 136, 196, 17, 56, 68, 153, 37, 109, 38, 146, 21, 182, 168, 31, 66, 59, 77, 64, 115, 75, 157, 47, 88, 18, 124, 201, 217, 208, 24, 35, 219, 74, 10, 30, 158, 55, 222, 250, 235, 40, 204, 44, 247, 121, 234, 117, 232, 253, 111, 13, 4, 200, 93, 154, 230, 108, 195, 245, 244, 129, 181, 79, 189, 212, 57, 92, 198, 12, 192, 107, 188, 62, 239, 2, 207, 19, 94, 180, 133, 36, 81, 214, 165, 163, 183, 32, 63, 0, 69, 20, 172, 162, 220, 106, 170, 22, 237, 144, 191, 211, 112, 71, 190, 76, 175, 96, 125, 114, 215, 26, 83, 89, 53, 206, 255, 16, 28, 61, 34, 227, 252, 3, 176, 120, 171, 248, 43, 72, 145, 210, 139, 178, 246, 156, 143, 110, 160, 51, 205, 197, 127, 103, 169, 1, 87, 251, 49, 177, 228, 52, 15, 221, 213, 229, 166, 233, 203, 179, 45, 60, 67, 141, 126, 122, 11, 150, 8, 39, 216, 130, 98, 58, 161, 70, 131, 185, 27, 5, 138, 149, 65, 231, 85, 151, 202, 193, 243, 73, 91, 41, 7, 50, 155, 240, 164, 82, 100, 101, 159, 209, 90, 137, 167, 236, 25, 225, 142, 218, 184, 86, 105, 46, 242, 113, 14, 23, 119, 254, 134, 54, 97, 123, 116, 241, 104, 6, 33, 186, 199, 48, 99, 78, 102, 226, 80, 9, 173, 135, 174, 118, 194, 224, 95, 187, 84, 249]

TEST_VECTORS = [
    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [245, 10, 7, 164, 73, 233, 39, 254, 185, 86, 142, 14, 169, 217, 125, 134]),
    ([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [36, 211, 54, 71, 93, 68, 151, 37, 91, 219, 6, 251, 52, 40, 207, 87]),
    ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [81, 20, 149, 160, 128, 165, 84, 126, 33, 114, 55, 125, 246, 196, 135, 131]),
    ([84, 69, 83, 84, 66, 76, 79, 67, 75, 95, 48, 48, 48, 48, 48, 49], [42, 141, 159, 96, 19, 137, 225, 250, 118, 182, 93, 172, 92, 195, 22, 175]),
    ([84, 69, 83, 84, 66, 76, 79, 67, 75, 95, 48, 48, 48, 48, 48, 50], [166, 77, 167, 12, 121, 170, 96, 6, 255, 234, 232, 130, 24, 150, 102, 255]),
    ([65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65], [106, 2, 143, 51, 174, 168, 119, 101, 151, 226, 58, 50, 38, 112, 199, 111]),
    ([66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66], [0, 200, 219, 155, 232, 232, 78, 54, 185, 13, 105, 59, 212, 189, 138, 198]),
    ([170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85], [177, 99, 173, 181, 185, 48, 115, 56, 76, 137, 142, 32, 10, 89, 52, 182]),
    ([85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170, 85, 170], [131, 1, 193, 154, 243, 79, 248, 92, 248, 192, 246, 195, 140, 110, 244, 157]),
    ([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [15, 4, 118, 230, 169, 56, 115, 35, 17, 10, 166, 219, 171, 102, 29, 61]),
    ([0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [162, 255, 93, 250, 162, 39, 231, 241, 240, 175, 212, 119, 62, 141, 217, 214]),
    ([0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [81, 177, 1, 163, 47, 57, 94, 229, 72, 92, 112, 20, 40, 4, 147, 29]),
    ([0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [135, 128, 220, 49, 80, 141, 31, 159, 230, 194, 190, 151, 146, 245, 197, 74]),
    ([0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [181, 63, 255, 34, 88, 194, 201, 74, 107, 181, 211, 67, 199, 137, 20, 205]),
    ([0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [195, 15, 215, 140, 0, 207, 76, 236, 162, 13, 94, 105, 92, 151, 254, 147]),
    ([0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0], [131, 163, 230, 217, 252, 55, 122, 160, 195, 191, 46, 202, 213, 184, 35, 218]),
    ([0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0], [52, 236, 141, 54, 252, 22, 109, 162, 188, 254, 240, 238, 23, 156, 83, 110]),
    ([0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [105, 1, 71, 130, 130, 84, 121, 116, 149, 155, 75, 96, 205, 49, 127, 131]),
    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [88, 150, 99, 174, 27, 26, 106, 234, 41, 93, 94, 136, 186, 226, 242, 254]),
    ([57, 12, 140, 125, 114, 71, 52, 44, 216, 16, 15, 47, 111, 119, 13, 101], [173, 173, 15, 215, 187, 187, 62, 62, 124, 55, 214, 100, 245, 191, 130, 169]),
    ([214, 112, 229, 142, 3, 81, 216, 174, 142, 79, 110, 172, 52, 47, 194, 49], [101, 219, 24, 77, 159, 11, 107, 61, 198, 237, 11, 162, 178, 165, 15, 113]),
    ([183, 176, 135, 22, 235, 63, 193, 40, 150, 185, 98, 35, 23, 116, 148, 40], [102, 210, 84, 230, 42, 251, 227, 16, 12, 5, 201, 184, 114, 135, 44, 163]),
    ([119, 51, 194, 142, 232, 186, 83, 189, 181, 107, 136, 36, 87, 125, 83, 236], [251, 5, 113, 184, 72, 30, 58, 166, 123, 77, 178, 31, 176, 85, 59, 200]),
    ([194, 138, 112, 166, 28, 117, 16, 161, 205, 137, 33, 108, 161, 108, 255, 202], [49, 155, 181, 178, 97, 129, 201, 29, 122, 216, 66, 33, 156, 58, 249, 158]),
    ([234, 73, 135, 71, 126, 134, 219, 204, 185, 112, 70, 252, 46, 24, 56, 78], [215, 252, 161, 116, 157, 16, 2, 128, 165, 156, 47, 254, 235, 165, 203, 170]),
    ([81, 216, 32, 197, 195, 239, 128, 5, 58, 136, 174, 57, 150, 222, 80, 232], [228, 201, 159, 245, 138, 37, 133, 150, 177, 142, 33, 251, 140, 202, 224, 184]),
    ([1, 134, 91, 54, 152, 101, 78, 191, 82, 0, 165, 250, 9, 57, 185, 157], [96, 178, 50, 198, 152, 142, 102, 248, 102, 42, 119, 76, 118, 93, 180, 155]),
    ([122, 29, 123, 40, 43, 248, 35, 64, 65, 243, 84, 135, 216, 108, 102, 159], [69, 33, 8, 94, 3, 183, 184, 238, 46, 4, 172, 25, 94, 110, 108, 200]),
    ([204, 191, 224, 231, 61, 126, 115, 32, 173, 10, 117, 112, 3, 36, 30, 117], [131, 9, 51, 135, 20, 36, 237, 28, 146, 164, 52, 40, 43, 76, 191, 218]),
]

def key_schedule(master_key):
    round_keys = bytearray(master_key[:32])
    for i in range(1, 12):
        rc = (master_key[0] << i) & 0xFF
        for j in range(16):
            round_keys.extend([(round_keys[(i-1) * 16 + j] ^ rc)])
    return bytes(round_keys[:192])

def substitute_bytes(state):
    return bytes([SBOX[b] for b in state])

def shift_rows(state):
    result = bytearray(16)
    result[0:4] = state[0:4]
    result[4:8] = state[5:8] + state[4:5]
    result[8:12] = state[10:12] + state[8:10]
    result[12:16] = state[15:16] + state[12:15]
    return bytes(result)

def mix_columns(state):
    """Invertible mix_columns using MDS matrix"""
    result = bytearray(16)
    
    def mul2(x):
        return ((x << 1) ^ 0x1b) & 0xff if x & 0x80 else (x << 1) & 0xff
    
    def mul3(x):
        return mul2(x) ^ x
    
    for i in range(4):
        col = [state[i], state[i+4], state[i+8], state[i+12]]
        result[i]    = mul2(col[0]) ^ mul3(col[1]) ^ col[2]       ^ col[3]
        result[i+4]  = col[0]       ^ mul2(col[1]) ^ mul3(col[2]) ^ col[3]
        result[i+8]  = col[0]       ^ col[1]       ^ mul2(col[2]) ^ mul3(col[3])
        result[i+12] = mul3(col[0]) ^ col[1]       ^ col[2]       ^ mul2(col[3])
    
    return bytes(result)

def add_round_key(state, round_key):
    return bytes([s ^ k for s, k in zip(state, round_key)])

def encrypt_block(plaintext, key):
    round_keys = key_schedule(key)
    state = plaintext
    
    for round_num in range(ROUNDS):
        state = substitute_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, round_keys[round_num*16:(round_num+1)*16])
    
    return state

def main():
    if len(sys.argv) < 2:
        print("OBLIVION Cipher Module v1.0")
        print("Usage: python cipher_module.py <input_file>")
        print("")
        print("Embedded test vectors: %d pairs" % len(TEST_VECTORS))
        print("Block size: %d bytes" % BLOCK_SIZE)
        print("Rounds: %d" % ROUNDS)
        print("")
        print("NOTE: Master key is 32 bytes. Test vectors can help recover it.")
        print("      Reference: https://stackoverflow.com/questions/2907262/what-does-dead-beef-mean")
        sys.exit(1)
    
    with open(sys.argv[1], 'rb') as f:
        data = f.read()
    
    if len(data) < BLOCK_SIZE:
        data += b'\x00' * (BLOCK_SIZE - len(data))
    
    print("ERROR: Key required for encryption")
    print("Analyze test vectors and implementation to recover key")
    sys.exit(1)

if __name__ == "__main__":
    main()
